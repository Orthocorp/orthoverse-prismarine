'use strict';

const Vec3 = require('vec3').Vec3;
const mcData = require('minecraft-data')('1.16.1')
const rand = require('random-seed')

const voxel = require('../../map-data/voxel.json');
const special = require('../../map-data/special.json');
const specialFn = require('./special.js');

const { 
  plain,
  mountain, hill, lake, 
  deciduous, evergreen, quarry, 
  desert, lush, sea
} = require('./terrain.js');

function generation ({ version = '1.15.2', seed } = {}) {
  const size = 101*6*16 // map width * tiles * chunk size
  const Chunk = require('prismarine-chunk')(version);
  const majorVersion = mcData.version.majorVersion;

  function generateSimpleChunk (chunkX, chunkY) {
    const chunk = new Chunk()
    const seedRand = rand.create(seed + ':' + chunkX + ':' + chunkY)
    let level = 20 + seedRand(2)
    // const worldX = chunkX * 16 + size / 2
    // const worldY = chunkY * 16 + size / 2
    /*
    console.log("\nChunk request:")
    console.log("chunkX: " + chunkX.toString() + " chunkY: " + chunkY.toString())
    */
    const tileX = Math.floor(chunkX/6)
    const tileY = Math.floor(chunkY/6)
    //console.log("Chunk is in tile " + tileX.toString() + ", " + tileY.toString())
    let posX = chunkX % 6
    let posY = chunkY % 6
    if (posX < 0 ) { posX += 6 }
    if (posY < 0 ) { posY += 6 }
    // console.log("We want character at index " + ((posY * 6) + posX).toString())
    const tileKey = tileX.toString() + ":" + tileY.toString();
    const posKey = posX.toString() + ":" + posY.toString();
    let feature;
    let castleLvl;
    let realm;
    let fn;

    if (tileKey in special) {
      // special features need flat land
      level = 21;
      feature = special[tileKey].feature[((posY * 6) + posX)];
      fn = specialFn[special[tileKey].function]
    } else if (tileKey in voxel) {
      // standard tile, but may contain a castle!
      feature = voxel[tileKey][0][((posY * 6) + posX) + 2];
      castleLvl = voxel[tileKey][2] % 8;
      realm = (voxel[tileKey][2] > 7) ? 1 : 0;
      if ((castleLvl > 0) && 
      ((posX == 2) || (posX == 3)) &&
      ((posY == 2) || (posY == 3))) { feature = '#' }
      level = 20;
    } else {
      feature = "g"
    }
    //
    // start with a plain
    plain(chunk, level, seedRand)
    // then put the required feature on top of it
    if (feature === "0") {  hill(chunk, level, seedRand, true) }; // lush hill
    if (feature === "1") {  mountain(chunk, level, seedRand, true) }; // lush mountain
    if (feature === "2") {  lake(chunk, seedRand) };
    if (feature === "3") { }; // plains - default terrain
    if (feature === "4") {  deciduous(chunk, level, seedRand) };
    if (feature === "5") {  lush(chunk, level, seedRand) }; // lush plains
    if (feature === "6") {  quarry(chunk, seedRand, true) };
    if (feature === "7") {  evergreen(chunk, level, seedRand) };
    if (feature === "8") {  hill(chunk, level, seedRand, false) }; // barren hill
    if (feature === "9") {  mountain(chunk, level, seedRand, false) }; // barren mountain
    if (feature === "a") {  lake(chunk, seedRand) };
    if (feature === "b") {  desert(chunk, seedRand, level, true) }; // desert plains
    if (feature === "c") {  deciduous(chunk, level, seedRand) };
    if (feature === "d") {  desert(chunk, seedRand, level, false) }; // badlands
    if (feature === "e") {  quarry(chunk, seedRand, false) }; // cobblestone quarry
    if (feature === "f") {  deciduous(chunk, level, seedRand) };
    if (feature === "g") {  sea(chunk, seedRand) };
    if (feature === "#") {  specialFn['castle'](chunk, level, seedRand, posX, posY) } // we have a castle
    if (fn) { 
      fn(chunk, level, seedRand, posX, posY, chunkX, chunkY)
    };

    return chunk
  }

  return generateSimpleChunk
}



module.exports = generation;
