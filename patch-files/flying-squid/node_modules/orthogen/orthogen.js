'use strict';

/*
Apologies in advance for the total mess this code is in
The aim was to do it quickly, not well
*/

const Vec3 = require('vec3').Vec3;
const mcData = require('minecraft-data')('1.15.2')
const rand = require('random-seed')

const special = require('../../map-data/special.json');
const specialFn = require('./special.js');

const { 
  plain,
  mountain, hill, lake, 
  deciduous, evergreen, quarry, 
  desert, lush, sea,
  tarmac, pyramid, slimelake, dome, cube, pit, square, prism, speckle,
  wall
} = require('./terrain.js');

function generation ( { version = '1.15.2', seed } = {}) {
  // map width for actual land is 101
  // add an extra 16 chunks of sea around the world
  // const size = 117*6*16 // map width * tiles * chunk size
  const Chunk = require('prismarine-chunk')(version);
  const majorVersion = mcData.version.majorVersion;

  function generateSimpleChunk (serv, chunkX, chunkZ) {
    const landX = Math.floor(chunkX/6)
    const landZ = Math.floor(chunkZ/6)
    // determine what the tile position is
    const landKey = landX.toString() + ":" + landZ.toString()
    if (landKey in serv.voxel.data) {
      // if tile is in our database and there is no status for this tile
      // generate the entire tile because this is the first time
      if (serv.voxel.data[landKey].length !== 7) {
        serv.voxel.data[landKey][6] = 0 // indicates use save slot 0
        generateDefaultLandChunks(serv, landX, landZ)
      }
      // at this point having a selected slot for the land should be
      // guaranteed, so return the chunk from the current slot as indicated by status
      const chunk = serv.voxel.loadChunkFromFile(serv.voxel.data[landKey][6],chunkX, chunkZ)
      return chunk
    } else {
      // if tile is not in our database, return a standard chunk
      // should be sea, or boundary lands
      return generateBasicChunk(serv, chunkX, chunkZ)
    }
  }

  // Takes a server, and an Orthoverse land X and Y position, and generates the 36 chunks that
  // it consists of, for saving as a default land save
  function generateDefaultLandChunks (serv, landX, landZ) {
    // this should only be called if the land is in the database
    const landKey = landX.toString() + ':' + landZ.toString()
    const chunkStartX = landX*6
    const chunkStartZ = landZ*6
    for (let chunkX = chunkStartX; chunkX < chunkStartX + 6; chunkX++) {
      for (let chunkZ = chunkStartZ; chunkZ < chunkStartZ + 6; chunkZ++) {
        // now we save the default land without edits in slot 0
        serv.voxel.saveChunkToFile(0, chunkX, chunkZ, generateBasicChunk(serv, chunkX, chunkZ))
      }
    }
  }

  function generateBasicChunk (serv, chunkX, chunkZ) {
    const chunk = new Chunk()
    const seedRand = rand.create(seed + ':' + chunkX + ':' + chunkZ)
    let level = 80 - 15 - 30 + 8
    /*
    console.log("\nChunk request:")
    console.log("chunkX: " + chunkX.toString() + " chunkZ: " + chunkZ.toString())
    */
    const landX = Math.floor(chunkX/6)
    const landZ = Math.floor(chunkZ/6)
    const landKey = landX.toString() + ":" + landZ.toString();
    // the coordinates for the tile under consideration is at landKey

    let posX = chunkX % 6
    let posY = chunkZ % 6
    if (posX < 0 ) { posX += 6 }
    if (posY < 0 ) { posY += 6 }
    // console.log("We want character at index " + ((posY * 6) + posX).toString())


    let feature;
    let castleLvl = 0;
    let realm = 0;
    let fn;
    // if tile is not on map, use sea by default
    let tokenId = "0x2222222222222222222222222222222222222220"
    // if we are at the boundary, use grass plains with mountains at the edge
    if ((landX === 57) || (landX === -57) || (landZ === 57) || (landZ === -57)) {
      tokenId = "0x3333333333333333333333333333333333333333"
      if (landZ == -57) {
        tokenId = tokenId.slice(0,2) + "111111" + tokenId.slice(8);
      }
      if (landZ == 57) {
        tokenId = tokenId.slice(0,32) + "111111" + tokenId.slice(38);
      }
      if (landX == 57) {
        for (let i = 0; i < 6; i++) {
          tokenId = tokenId.slice(0,7 + i*6) + "1" + tokenId.slice(8 + i*6);
        }
      }
      if (landX == -57) {
        for (let i = 0; i < 6; i++) {
          tokenId = tokenId.slice(0,2 + i*6) + "1" + tokenId.slice(3 + i*6);
        }
      }
    }
    if (landKey in serv.voxel.data) {
      tokenId = serv.voxel.data[landKey][0];
    }

    if (landKey in special) {
      // special features need flat land
      feature = special[landKey].feature[((posY * 6) + posX)];
      fn = specialFn[special[landKey].function]
    } else if (landKey in serv.voxel.data) {
      castleLvl = serv.voxel.data[landKey][2] % 8;
      realm = (serv.voxel.data[landKey][2] > 7) ? 1 : 0;
      // standard tile, but may contain a castle!
      feature = serv.voxel.data[landKey][0][((posY * 6) + posX) + 2];
      // castle
      if (((castleLvl > 0) && (realm === 0)) &&
      ((posX === 2) || (posX === 3)) &&
      ((posY === 2) || (posY === 3))) { feature = '#' }
      if (((castleLvl > 0) && (realm === 1)) &&
      ((posX === 2) || (posX === 3)) &&
      ((posY === 4) || (posY === 5))) { feature = '#' }
    } else if ((landX === 58) || (landX === -58) || (landZ === 58) || (landZ === -58)) {
      feature = "h";
    } else if (tokenId !== "0x2222222222222222222222222222222222222220") { // we have wall
      feature = tokenId[((posY * 6) + posX) + 2];
    } else {  // we have sea
      feature = "g"
    }
    //
    if (realm === 0) {
    // start with a plain
      plain(chunk, level, seedRand)
      // then put the required feature on top of it
      if (feature === "0") {  hill(chunk, level, seedRand, true) }; // lush hill
      if (feature === "1") {  mountain(chunk, level, seedRand, true) }; // lush mountain
      if (feature === "2") {  lake(chunk, seedRand) };
      if (feature === "3") { }; // plains - default terrain
      if (feature === "4") {  deciduous(chunk, level, seedRand) };
      if (feature === "5") {  lush(chunk, level, seedRand) }; // lush plains
      if (feature === "6") {  quarry(chunk, seedRand, true) };
      if (feature === "7") {  evergreen(chunk, level, seedRand) };
      if (feature === "8") {  hill(chunk, level, seedRand, false) }; // barren hill
      if (feature === "9") {  mountain(chunk, level, seedRand, false) }; // barren mountain
      if (feature === "a") {  lake(chunk, seedRand) };
      if (feature === "b") {  desert(chunk, seedRand, level, true) }; // desert plains
      if (feature === "c") {  deciduous(chunk, level, seedRand) };
      if (feature === "d") {  desert(chunk, seedRand, level, false) }; // badlands
      if (feature === "e") {  quarry(chunk, seedRand, false) }; // cobblestone quarry
      if (feature === "f") {  deciduous(chunk, level, seedRand) };
      if (feature === "g") {  sea(chunk, seedRand) };
      if (feature === "h") {  wall(chunk, seedRand) };
      if (feature === "#") {  
        specialFn['castle_' + castleLvl.toString()](chunk, level, seedRand, posX, posY) 
      } // we have a castle
    } else {
    // start with tarmac
      tarmac(chunk, level, seedRand)
      // then put the required feature on top of it
      if (feature === "0") {  cube(chunk, level, true) }; // lush hill
      if (feature === "1") {  pyramid(chunk, level, true) }; // lush mountain
      if (feature === "2") {  slimelake(chunk, seedRand) };
      if (feature === "3") {  square(chunk, level, true)}; // tarmac - default terrain
      if (feature === "4") {  dome(chunk, level, true) };
      if (feature === "5") {  speckle(chunk, level, seedRand, true) }; // lush plains
      if (feature === "6") {  pit(chunk, true) };
      if (feature === "7") {  prism(chunk, level, true) };
      if (feature === "8") {  cube(chunk, level) }; // barren hill
      if (feature === "9") {  pyramid(chunk, level, seedRand, false) }; // barren mountain
      if (feature === "a") {  slimelake(chunk, seedRand) };
      if (feature === "b") {  square(chunk, level, false) }; // desert plains
      if (feature === "c") {  dome(chunk, level, false) };
      if (feature === "d") {  speckle(chunk, level, seedRand, false) }; // badlands
      if (feature === "e") {  pit(chunk, false) }; // cobblestone quarry
      if (feature === "f") {  prism(chunk, level, false) };
      if (feature === "g") {  sea(chunk, seedRand) };
      if (feature === "h") {  wall(chunk, seedRand) };
      if (feature === "#") {  
        specialFn['castle_' + (castleLvl + 8).toString()](chunk, level, seedRand, posX, posY, tokenId) 
      } // we have a castle
    }
    if (fn) { 
      fn(chunk, level, seedRand, posX, posY, chunkX, chunkZ)
    };

    return chunk
  }

  return generateSimpleChunk
}



module.exports = generation;
